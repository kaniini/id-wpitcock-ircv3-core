<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC1459 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1459.xml">
  <!ENTITY RFC2812 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2812.xml">
  <!ENTITY RFC3629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
  <!ENTITY RFC3454 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3454.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-wpitcock-ircv3-core" obsoletes="1459, 2812">
    <front>
        <title abbrev="IRCv3 Core">Internet Relay Chat Core Protocol version 3</title>
        <author fullname="William Pitcock" initials="W." surname="Pitcock" role="editor">
            <organization>mammon.io</organization>
            <address>
                <email>nenolod@dereferenced.org</email>
                <uri>http://kaniini.dereferenced.org/</uri>
            </address>
        </author>
        <author fullname="Jack Allnutt" initials="J." surname="Allnutt">
            <organization>Kiwi IRC</organization>
            <address>
                <email>jack@allnutt.eu</email>
                <uri>http://allnutt.eu/</uri>
            </address>
        </author>
        <author fullname="Lalit Maganti" initials="L." surname="Maganti">
            <organization>FusionX</organization>
            <address>
                <email>lalitmaganti@gmail.com</email>
                <uri>https://github.com/tilal6991/</uri>
            </address>
        </author>
        <date year="2015" />
        <area>General</area>
        <workgroup>Network Working Group</workgroup>
        <keyword>IRC</keyword>
        <keyword>IRCv3</keyword>
        <keyword>Chat</keyword>
        <abstract>
            <t>The IRC protocol has been developed by the greater IRC user and administrator community since
            the first version formalized in <xref target="RFC1459"/>.  It has adapted over the years to be the
            primary collaboration tool for many groups because of it's simplicity and robustness.</t>

            <t>The IRC Core Protocol version 3 updates <xref target="RFC1459"/> and <xref target="RFC2812"/> with
            a base protocol and framework for extensions which has been developed over the past decade, as well as
            standardizes current known best practices in the greater IRC community.  The IRC Core Protocol version 3
            framework mechanisms also provide some level of compatibility with legacy IRC clients.</t>
        </abstract>
    </front>
    <middle>
        <section title="Requirements Language">
            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
            "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
            document are to be interpreted as described in <xref target="RFC2119"/>.</t>
        </section>
        <section title="Introduction">
            <t>IRC networks have been maintained over several decades for use with text-based conferencing.
            This document describes the core IRC client protocol and a framework for extending the protocol.</t>

            <t>IRC itself is a distributed teleconferencing and signalling system which is well-suited for running
            on many machines in a distributed manner.  A typical setup involves many clients connecting to an IRC
            server which is connected to other servers in the network.  The IRC server handles all of the necessary
            message routing and broadcast tasks.</t>

            <section title="Servers">
                <t>In a typical IRC network, the servers are linked to each other in a topology which resembles an
                acyclic graph, however, some experimental networks have developed alternative topologies such as
                mesh-like topologies.  Other IRC server software implements support for hot failover connections,
                however this is usually dependent on a specialized server-to-server protocol.</t>
            </section>

            <section title="Clients">
                <t>A client is anything connected to a server which is using the IRC client protocol.  Each client
                is distinguished from other clients by having a unique nickname.  In addition to the nickname, every
                server on the network maintains other information on the client, such as the real hostname of the
                client, the username that the client has selected and other information about the client such as the
                name of the user.</t>

                <section title="IRC Operators">
                    <t>To facilitate maintenance of the network, IRC features a type of privileged user known as an
                    "IRC operator".  IRC operators are granted special privilege to perform maintenance-related tasks
                    such as rerouting servers as needed to mitigate bad network routing.</t>

                    <t>Operators also typically have the ability to enforce network policy by removing users from the
                    network who do not comply with the network's policies.</t>
                </section>
            </section>

            <section title="Channels">
                <t>A channel is a named group of zero or more clients which will all receive messages that
                are addressed to that channel.  The channel is typically created when the first client joins
                it, and typically ceases to exist when the last client leaves it, however some IRC server software
                support keeping the channel open when no clients are presently using it in order to maintain
                the channel's settings.</t>

                <t>Channel names are strings which begin with a configured CHANPREFIX of length up to a
                configured CHANNELLEN length.  Apart from the requirement that the channel name begin with
                a recognized CHANPREFIX, the only other restriction is that may not contain any spaces,
                control codes or commas (&quot;,&quot;) which is used as a list-item separator by the protocol.</t>

                <section title="Channel Statuses">
                    <t>A channel may have zero or more channel operators which provide for the maintenance and
                    moderation of the channel.  Depending on the server software in use, the channel operators may
                    have special sigils as designated by the PREFIX configuration value.</t>

                    <t>In a channel which is moderated, users which are allowed to bypass the moderation are given
                    "voice" status.  Users who have "voice" status MAY be given the &quot;+&quot; sigil to designate
                    that they have the ability to bypass moderation.</t>
                </section>
            </section>

            <section title="Services, Accounts and Authentication">
                <t>A common feature of the present-day IRC networks are the usage of services servers.  These servers
                provide specialized bots which provide an authentication layer on the network, allowing for ownership of
                nicknames and channels.  Services usually provide facilities for account management and authentication,
                and map ownership of objects such as nicknames and channels to those accounts.</t>
            </section>
        </section>
        <section title="The IRC Client Protocol">
            <section title="Overview">
                <t>This protocol is a superset of <xref target="RFC1459" />, and is intended to be backwards compatible with
                <xref target="RFC1459" /> where possible.  It describes only the client side of the protocol unlike <xref target="RFC1459" />,
                as the server protocols have diverged over the years and are no longer compatible.</t>
            </section>
            <section title="Character Encoding">
                <t>While <xref target="RFC1459" /> does not specify any specific character set, servers implementing the IRCv3 core
                protocol SHOULD use UTF-8 as defined by <xref target="RFC3629" />.  Clients SHOULD send UTF-8 unless explicitly configured
                not to do so.</t>

                <t>Because of IRC's Scandinavian origin, some IRC servers specify that the characters {}| be mapped to be the lower-case
                equivalents of []\.  This is specified using the CASEMAPPING configuration attribute, and an IRC network MUST use the same
                CASEMAPPING attribute in the entire network.</t>
            </section>
            <section title="Messages">
                <t>Servers and clients send messages between each other which may or may not generate a reply.  If the
                message contains a valid command, as described in later sections, the client SHOULD expect a reply as specified,
                but it is not advised to wait for the reply.  Client to server communications should be treated as asynchronous
                in nature.</t>

                <t>IRC messages consist of up to four parts: the tags section (optional), the prefix (optional), the command and it's
                parameters.  All components of the message are separated using the UTF-8 space character (0x20).</t>

                <t>The presence of a tags section is designated with a single leading &quot;@&quot; symbol (0x40).  The tags section
                consists of a set of key-value pairs delimited by an equals sign (0x3D).  Each key-value pair is delimited by a
                semi-colon (&quot;;&quot;) (0x3B), which may be escaped using a backslash (&quot;\&quot;) (0x5C).  There MUST NOT be
                any whitespace between the &quot;@&quot; symbol and the key-value pairs.</t>

                <t>The presence of a prefix is designated with a single leading colon (&quot;:&quot;) (0x3A).  There MUST NOT be any
                whitespace between the &quot;:&quot; symbol and the prefix itself.  The prefix is used by servers to designate the
                origin of the message.  If the prefix is missing, then clients SHOULD assume it came from the server the client is
                connected to.  Clients SHOULD NOT use the prefix when they are sending a message to a server, but MAY send relevant
                tags.</t>

                <t>The command must be either a valid IRC command or a three-digit number represented in UTF-8 text.</t>

                <t>IRC messages are always lines of characters delimited with a CR-LF (Carriage Return - Line Feed) pair, and these
                messages SHOULD NOT exceed 1024 octets in length (512 bytes for tags, 512 for the rest) unless otherwise indicated
                by the server (see <xref target="ISUPPORT-LINELEN" />).  If the limit is exceeded, the line MAY be silently truncated.</t>

                <section anchor="message-ABNF" title="Message Format in Augmented BNF">
                    <t>The protocol messages must be extracted from the contiguous stream of octets.  The current solution is to designate
                    two characters, CR and LF, as separators.  Empty messages are silently ignored, which permits the use of the sequence
                    CR-LF between messages without extra problems.</t>

                    <t>The extracted message is parsed into the components &lt;tags&gt;, &lt;prefix&gt;, &lt;command&gt; and list
                    of parameters (&lt;params&gt;).</t>

                    <t>The Augmented BNF representation for this is:</t>

                    <figure><artwork type="abnf"><![CDATA[
message      =  [ "@" tags SPACE ] [ ":" prefix SPACE ] command [ params ] crlf
prefix       =  servername / ( nickname [ [ "!" user ] "@" host ] )
command      =  1*letter / 3digit
params       =  *14( SPACE middle ) [ SPACE ":" trailing ]
             =/ 14( SPACE middle ) [ SPACE [ ":" ] trailing ]

nospcrlfcl   =  %x01-09 / %x0B-0C / %x0E-1F / %x21-39 / %x3B-FF
                    ; any octet except NUL, CR, LF, " " and ":"
middle       =  nospcrlfcl *( ":" / nospcrlfcl )
trailing     =  *( ":" / " " / nospcrlfcl )

tags         =  tag [';' tag]*
tag          =  key ['=' value]
nospcrlfscl  =  %x01-09 / %x0B-0C / %x0E-1F / %x21-39 / %x3C-FF
key          =  [ vendor '/' ] *( nospcrflscl )
value        =  nospcrflscl *( nospcrflscl )

SPACE        =  %x20        ; space character
crlf         =  %x0D %x0A   ; "carriage return" "linefeed"]]></artwork></figure>

                    <t>Notes:
                       <list style="numbers">
                           <t>SPACE explicitly is only the octet 0x20.  Other forms of whitespace, such as tabs, are not considered part of SPACE.</t>
                           <t>After extracting the parameter list, all parameters are equal, whether matched by &quot;middle&quot; or &quot;trailing&quot;.
                              &quot;trailing&quot; is just a syntactic trick to allow SPACE within parameter.</t>
                           <t>The NUL character is not special in message framing but as it would cause extra complexities in normal C string handling
                              it is not allowed within messages.</t>
                           <t>The trailing parameter may be an empty string.</t>
                       </list>
                    </t>

                    <t>Most protocol messages specify additional semantics and syntax for the extracted parameter strings dictated by their position
                       in the list.  For example, many server commands will assume that the first parameter after the command is the list of targets.</t>
                </section>
            </section>
            <section title="Numeric replies">
                <t>Most of the messages sent to the server generate a reply of some sort.  The most common type of reply is a
                numeric reply, used for both errors and normal replies.  The numeric reply MUST be sent as one message consisting
                of the sender prefix, the three-digit numeric and the target of the reply.  A numeric reply MUST NOT originate from
                the client.  In all other respects, a numeric reply SHOULD be treated as any other message, with the exception that
                the command keyword is made up of 3 numeric digits rather than a string of letters.  A list of different replies is
                included in <xref target="replies" />.</t>
            </section>
            <section title="Wildcard expressions">
                <t>When wildcards are allowed in a string, it is referred as a "mask".</t>

                <t>For string matching purposes, the protocol allows the use of two special characters: &quot;?&quot; (0x3F) to
                match one and only one character, and &quot;*&quot; (0x2A) to match any number of any characters.  These two
                characters can be escaped using the character &quot;\&quot; (0x5C).</t>

                <t>The Augmented BNF syntax for this is:</t>

                <figure><artwork type="abnf"><![CDATA[
    mask       =  *( nowild / noesc wildone / noesc wildmany )
    wildone    =  %x3F
    wildmany   =  %x2A
    nowild     =  %x01-29 / %x2B-3E / %x40-FF
                    ; any octet except NUL, "*", "?"
    noesc      =  %x01-5B / %x5D-FF
                    ; any octet except NUL and "\"
    matchone   =  %x01-FF
                    ; matches wildone
    matchmany  =  *matchone
                    ; matches wildmany]]></artwork></figure>
            </section>
            <section anchor="registration" title="Connection registration">
                <t>Immediately upon establishing a connection the client must attempt registration without waiting for any banner message from the server.</t>
                <t>Until registration is complete, only a small subset of commands may be accepted by the server.</t>
                <t>The recommended order of commands during registration is:
                   <list style="numbers">
                       <t>STARTTLS</t>
                       <t>PASS</t>
                       <t>CAP</t>
                       <t>NICK</t>
                       <t>USER</t>
                   </list>
                </t>
                <t>If the transport layer is not secured by TLS it is RECOMMENDED that the client attempt to opportunistically enable encryption by sending
                the STARTTLS (see <xref target="cmd-STARTTLS" />) command before sending any other messages.</t>
                <t>The PASS command (see <xref target="cmd-PASS" />) is not required for the connection to be registered, but if included it MUST precede the
                latter of the NICK and USER commands.</t>
                <t>If the server supports capability negotiation the CAP command (see <xref target="cmd-CAP" />) suspends the registration process and immediately
                starts the capability negotiation process.  See <xref target="capability-negotiation" /> for more information.</t>
                <t>The NICK and USER commands (see <xref target="cmd-NICK" /> and <xref target="cmd-USER" />, respectively) are used to identify the user's nickname,
                username and "real name". Once both commands have been submitted, the registration process will end, unless it is still suspended by a STARTTLS or
                CAP negotiation.</t>
                <t>Upon successful completion of the registration process, the server MUST send the RPL_WELCOME (001) and RPL_ISUPPORT (005) numerics.
                The server SHOULD also send the MOTD (Message of the Day), if one exists, and MAY send other numerics.</t>
                <t>The RPL_ISUPPORT (005) numeric contains significant information for clients and is covered in more detail in <xref target="reply-RPL_ISUPPORT" />.</t>
                <section anchor="capability-negotiation" title="Capability negotiation">
                    <t>IRC is an asynchronous protocol, which means that IRC clients may issue additional IRC commands while previous commands are being processed.
                    Some servers also do not complain about unknown commands during registration, which means that a client cannot reliably do passive implementation
                    discovery at registration time.</t>

                    <t>The solution to these problems is to extend the registration process with actual capability negotiation.  If the server supports capability
                    negotiation, the registration process will be suspended until negotiation is completed.  If the server does not support capability negotiation,
                    then registration will complete immediately, and the client will not use any IRCv3 capabilities.</t>

                    <t>Capability negotiation is started by the client issuing a CAP LS command.  Negotiation is then performed with the CAP REQ, CAP ACK, and CAP NAK
                    commands, and ended with the CAP END command.  See <xref target="cmd-CAP" /> for more information.</t>

                    <t>Once capability negotiation has ended, the registration process SHALL resume.</t>

<!--                    <t>The rules for naming and registering capabilities are detailed in <xref target="capability-registry" />.</t> -->
                </section>
            </section>
            <section anchor="commands" title="Commands">
                <section anchor="cmd-CAP" title="CAP">
                </section>
                <section anchor="cmd-NICK" title="NICK">
                    <t>Syntax: "NICK &lt;new nickname&gt;"</t>

                    <t>The NICK message serves a dual purpose: it can be used to give the user a nickname or it can be used by an existing user to
                    change their nickname.</t>

                    <t>Numeric Replies:
                        <list>
                            <t><xref target="error-ERR_ERRONEOUSNICKNAME" format="title" /></t>
                            <t><xref target="error-ERR_NICKNAMEINUSE" format="title" /></t>
                            <t><xref target="error-ERR_NICKCOLLISION" format="title" /></t>
                        </list>
                    </t>
                </section>
                <section anchor="cmd-USER" title="USER">
                    <t>Syntax: "USER &lt;username&gt; &lt;ignored&gt; &lt;ignored&gt; &lt;realname&gt;"</t>

                    <t>The USER message is used at registration time to inform the server of the username and realname of the user.</t>

                    <t>The realname parameter may contain a space and if so MUST be preceeded by the colon (:) delimiter.</t>

                    <t>NOTE: parameters 2 and 3 are ignored and are simply included for backward compatibility with <xref target="RFC1459" /></t>

                    <t>Numeric Replies:
                        <list>
                            <t><xref target="error-ERR_NEEDMOREPARAMS" format="title" /></t>
                            <t><xref target="error-ERR_ALREADYREGISTRED" format="title" /></t>
                        </list>
                    </t>
                </section>
                <section anchor="cmd-PASS" title="PASS">
                    <t>Syntax: "PASS &lt;password&gt;"</t>

                    <t>The PASS message is used at registration time to provide a password to fully open a connection with the server. It SHOULD NOT be used to authenticate
                    the user and is instead intended to be a way of limiting access to the server to only those with access to the password.</t>

                    <t>The PASS command can be sent multiple times but only the last attempt is utilized and the command SHOULD NOT be used after registration.</t>

                    <t>Numeric Replies:
                        <list>
                            <t><xref target="error-ERR_NEEDMOREPARAMS" format="title" /></t>
                            <t><xref target="error-ERR_ALREADYREGISTRED" format="title" /></t>
                        </list>
                    </t>
                </section>
                <section anchor="cmd-STARTTLS" title="STARTTLS">
                </section>
            </section>
            <section anchor="replies" title="Replies">
                <section anchor="reply-RPL_WELCOME" title="RPL_WELCOME (001)">
                    <t>Syntax: "001 &lt;nickname&gt; :Welcome to the &lt;network name&gt; Internet Relay Chat Network &lt;nick&gt;!&lt;username&gt;@&lt;hostname&gt;"</t>

                    <t>Once client registration is complete, the server MUST send the RPL_WELCOME (001) numeric to the client.
                    The numeric SHOULD be sent before any other numerics.</t>

                    <t>The numeric is only intended to acknowledge that the registration is finished, but it is RECOMMENDED that the descriptive
                    text adhere to the specified format.</t>
                </section>
                <section anchor="reply-RPL_ISUPPORT" title="RPL_ISUPPORT (005)">
                    <t>Syntax: "005 &lt;nickname&gt; &lt;tokens...&gt; :are provided by this server"</t>

                    <t>Once client registration is complete, the server MUST send at least one RPL_ISUPPORT (005) numeric to the client.
                    The server MAY send more than one RPL_ISUPPORT numeric and it is RECOMMENDED that consecutive RPL_ISUPPORT numerics
                    are sent adjacent to each other.</t>

                    <t>Each parameter of this numeric is a token and optional value in the form of TOKEN[=VALUE].  The tokens MUST be sent
                    in upper-case but, unless otherwise specified, the value MUST be treated as case-sensitive.</t>

                    <section anchor="list-ISUPPORT-tokens" title="List of standard RPL_ISUPPORT tokens">
                        <section anchor="ISUPPORT-CASEMAPPING" title="CASEMAPPING">
                            <t>Syntax: CASEMAPPING=string</t>

                            <t>The CASEMAPPING parameter allows the server to specify which method it uses to compare equality
                            of case-insensitive strings.  Possible values are:
                               <list style="symbols">
                                   <t>"ascii": The ASCII characters 0x61 through 0x7a are defined as the lower-case characters of ASCII
                                   characters 0x41 through 0x5a.  No other equivalency is defined.</t>

                                   <t>"rfc1459": The ASCII characters 0x61 through 0x7e are defined as the lower-case characters of ASCII
                                   characters 0x41 through 0x5e.  No other equivalency is defined.</t>

                                   <t>"strict-rfc1459": The ASCII characters 0x61 through 0x7d are defined as the lower-case characters
                                   of ASCII characters 0x41 through 0x5d.  No other equivalency is defined.</t>

                                   <t>"rfc3454": Strings are compared using the stringprep method described in <xref target="RFC3454" />.</t>
                               </list>
                            </t>

                            <t>New implementations SHOULD default to using the "rfc3454" method in the event that this token is not available.</t>
                        </section>

                        <section anchor="ISUPPORT-PREFIX" title="PREFIX">
                            <t>Syntax: PREFIX=[(modes)prefixes]</t>

                            <t>The PREFIX parameter specifies a list of channel status flags (the "modes" section) that clients may have on channels, followed by a
                            mapping to the equivalent channel status flags ("prefixes"), which are used in NAMES and WHO replies.  There is a one to one mapping
                            between each mode and prefix.</t>

                            <t>The order of the modes is from that which gives most privileges on the channel, to that which gives the least.</t>

                            <t>The default value for PREFIX is "PREFIX=(ov)@+", which corresponds to <xref target="RFC1459" />.  It SHOULD NOT be specified if the
                            server provides only these modes.  If a server provides ANY additional status flags, it MUST also provide (ov)@+ (assuming they are applicable
                            to the server). The PREFIX parameter may be advertised with a null value specifier; this indicates that no prefixes are supported by the IRC server.</t>

                            <t>Note that PREFIX does NOT specify whether or not the server sends multiple prefix characters for a user in NAMES replies.</t>
                        </section>

                        <section anchor="ISUPPORT-CHANTYPES" title="CHANTYPES">
                            <t>Syntax: CHANTYPES=chars</t>

                            <t>The CHANTYPES parameter specifies the valid characters to begin a channel name.</t>

                            <t>The default value for CHANTYPES is "CHANTYPES=#&amp;", which corresponds to <xref target="RFC1459" />.  It SHOULD NOT be
                            specified if the server supports exactly these channel types.</t>

                            <t>The CHANMODES parameter does not require a value; if none is given, the server does not support any channel types.</t>
                        </section>

                        <section anchor="ISUPPORT-CHANMODES" title="CHANMODES">
                            <t>Syntax: CHANMODES=A,B,C,D</t>

                            <t>The CHANMODES token specifies the modes that may be set on a channel.  These modes are split into four categories, as follows:
                                <list style="symbols">
                                    <t>Type A: Modes that add or remove an address to or from a list.  These modes always take a parameter when sent by the
                                    server to a client; when sent by a client, they may be specified without a parameter, which requests the server to display
                                    the current contents of the corresponding list on the channel to the client.</t>

                                    <t>Type B: Modes that change a setting on the channel.  These modes always take a parameter.</t>

                                    <t>Type C: Modes that change a setting on the channel.  These modes take a parameter only when set; the parameter is absent
                                    when the mode is removed both in the client's and server's MODE command.</t>

                                    <t>Type D: Modes that change a setting on the channel.  These modes never take a parameter.</t>
                                </list>
                            </t>

                            <t>If the server sends any additional types after these 4, the client MUST ignore them.  The IRC server MUST NOT list modes in
                            CHANMODES which are also present in the PREFIX parameter; however, for completeness, modes described in PREFIX may be treated as
                            type B modes.</t>

                            <t>If the server does not support any modes corresponding to a particular type, it should advertise that type as the empty string.</t>

                            <t>The default value for the CHANMODES token is: "beI,k,l,imnpst".</t>
                        </section>

                        <section anchor="ISUPPORT-NETWORK" title="NETWORK">
                            <t>Syntax: NETWORK=name</t>

                            <t>The NETWORK parameter defines the name of the IRC network that the client is connected to.</t>

                            <t>Note that this parameter is intended only for user display purposes; the client SHOULD NOT assume further capabilities or features of the
                            IRC server based on the value of the NETWORK parameter.</t>

                            <t>The default value of the NETWORK token is no value; that is, the network does not have a name specified.</t>
                        </section>

                        <section anchor="ISUPPORT-MODES" title="MODES">
                            <t>Syntax: MODES=number</t>

                            <t>This parameter specifies the maximum number of "variable" modes which may by set on a channel by a single MODE command from a client.  A
                            "variable" mode is defined as being type A, B and C modes as defined for CHANMODES, and channel modes specified in the PREFIX parameter.</t>

                            <t>The value of MODES does not limit the number of modes in a MODE command which is sent from the server to the client; the client MUST NOT
                            rely on this being the case.</t>

                            <t>The default value for the MODES parameter is 3, which corresponds to <xref target="RFC1459" />.</t>

                            <t>The MODES token does not require a value; if none is given, the number of modes which may be set in one command is not limited.</t>
                        </section>

                        <section anchor="ISUPPORT-CHANLIMIT" title="CHANLIMIT">
                            <t>Syntax: CHANLIMIT=pfx:num[,pfx:num,...]</t>

                            <t>This parameter specifies the maximum number of channels that a client may join.
                            The value is a series of "pfx:num" pairs, where 'pfx' refers to one or more channel prefix characters (as specified in
                            CHANTYPES), and 'num' indicates how many of these types of channel the client may join in total.  If there is no limit
                            to the number of certain channel type(s) a client may join, the limit should be specified as the empty string, for
                            example "#:".</t>

                            <t>Clients on either this server or a remote server may be on more than this number of channels; this parameter is only
                            intended for information on how many channels the client it is advertised to may join.</t>

                            <t>There is no default value for the CHANLIMIT token.</t>
                        </section>

                        <section anchor="ISUPPORT-MAXLIST" title="MAXLIST">
                            <t>Syntax: MAXLIST=mode:num[,mode:num,...]</t>

                            <t>This parameter specifies the maximum numbers of 'list modes' (type A modes in CHANMODES) that a client may set on a channel at one time.
                            Note that this MUST only be interpreted as applying to new modes which are set by clients -- it should not be used to infer the maximum
                            length of any mode lists returned by the server.</t>

                            <t>The parameter is a series of mode-number pairs, each of which specifies one or more type A modes, along with the maximum size of
                            the associated list for those modes.  Modes which are specified in the same pair share the same maximum size.</t>

                            <t>The MAXLIST token MUST have a value.</t>

                            <t>There is no default value for the MAXLIST token.</t>
                        </section>

                        <section anchor="ISUPPORT-SAFELIST" title="SAFELIST">
                            <t>Syntax: SAFELIST</t>

                            <t>The SAFELIST parameter indicates that the client may request a "LIST" command from the server, without risking a disconnection
                            due to the large amount of data generated by the command.</t>

                            <t>The SAFELIST token MUST NOT be specified with a value.</t>

                            <t>The default value for the SAFELIST token is none; that is, the client may not safely request a LIST command.</t>
                        </section>

                        <section anchor="ISUPPORT-STATUSMSG" title="STATUSMSG">
                            <t>Syntax: STATUSMSG=string</t>

                            <t>The STATUSMSG token indicates that the server supports sending a NOTICE message to only those people on a channel with the specified status.
                            This is done via a NOTICE command, with the channel prefixed by the desired status flag as the target (e.g. @#channel).</t>

                            <t>The server should deliver the message to all users on the specified channel with equal or higher status on the channel as the status flag indicates.</t>

                            <t>The required value argument to STATUSMSG indicates which prefixes (from the PREFIX parameter) are valid status values for use in NOTICE commands.</t>

                            <t>The server MUST NOT advertise a character in STATUSMSG which is also present in CHANTYPES.</t>

                            <t>The STATUSMSG token MUST have a value if present.</t>

                            <t>The default value of the STATUSMSG token is none; that is, the server does not support this form of messaging.</t>
                        </section>

                        <section anchor="ISUPPORT-CALLERID" title="CALLERID">
                            <t>Syntax: CALLERID=char</t>

                            <t>The CALLERID parameter indicates that the server supports so-called "caller id" mode, which rejects PRIVMSG messages from
                            unauthorized users.</t>

                            <t>The CALLERID value if set indicates the mode-letter to enable this feature.  The CALLERID value MUST be set.</t>

                            <t>There is no default value for the CALLERID token.</t>
                        </section>

                        <section anchor="ISUPPORT-NICKLEN" title="NICKLEN">
                            <t>Syntax: NICKLEN=integer</t>

                            <t>An integer value which describes the maximum allowed length of a nickname in octets. The default value is 9.</t>
                        </section>

                        <section anchor="ISUPPORT-CHANNELLEN" title="CHANNELLEN">
                            <t>Syntax: CHANNELLEN=integer</t>

                            <t>An integer value which describes the maximum allowed length of a channel name in octets.</t>

                            <t>The default value for CHANNELLEN is 200.  The CHANNELLEN token does not require a value, if none
                            is given, channel names are not limited in length.</t>
                        </section>

                        <section anchor="ISUPPORT-TOPICLEN" title="TOPICLEN">
                            <t>Syntax: TOPICLEN[=integer]</t>

                            <t>An integer value which describes the maximum allowed length of a channel's topic in octets.</t>

                            <t>The TOPICLEN token does not require a value; if none is given, the length of channel topics is not limited. If the token is not specified at all, the default value is 390. <!-- TODO: Is this actually the default? Find out. --></t>
                        </section>

                        <section anchor="ISUPPORT-AWAYLEN" title="AWAYLEN">
                            <t>Syntax: AWAYLEN=integer</t>

                            <t>An integer value which describes the maximum allowed length of an away message in octets.</t>

                            <t>The AWAYLEN token does not require a value; if none is given, the length of away messages is not limited.</t>
                        </section>

                        <section anchor="ISUPPORT-USERLEN" title="USERLEN">
                            <t>Syntax: USERLEN=integer</t>

                            <t>An integer value which describes the maximum allowed length of an username in octets.</t>

                            <t>The USERLEN token does not require a value; if none is given, the length of usernames is not limited.</t>
                        </section>

                        <section anchor="ISUPPORT-LINELEN" title="LINELEN">
                            <t>Syntax: LINELEN=integer</t>

                            <t>An integer value which describes the maximum allowed length of a single IRC message (line) in octets.</t>

                            <t>The LINELEN token defaults to a value of 512 for compatibility with legacy IRC implementations.  There is no specified
                            upper bound for LINELEN.</t>
                        </section>
                    </section>
                </section>
                <section anchor="reply-RPL_TOPICWHOTIME" title="RPL_TOPICWHOTIME (333)">
                    <t>Syntax: "333 &lt;nickname&gt; &lt;channel&gt; &lt;topic-setter-nick&gt;!&lt;username&gt;@&lt;hostname&gt; &lt;timestamp&gt;"</t>

                    <t>After a channel is joined, and RPL_TOPIC (332) is sent, the server SHOULD send the RPL_TOPICWHOTIME (333) numeric to the client.</t>

                    <t>The numeric provides information about who set the channel topic and when. &lt;timestamp&gt; is an epoch time in seconds</t>
                </section>
            </section>
            <section anchor="errors" title="Errors">
                <section anchor="error-ERR_ERRONEOUSNICKNAME" title="ERR_ERRONEOUSNICKNAME (432)">
                    <t>Syntax: "432 &lt;nickname&gt; :Erroneous nickname"</t>

                    <t>Returned when a NICK command is sent with a nickname argument which does not comply with the format of a nickname set out in <xref target="message-ABNF" /></t>
                </section>
                <section anchor="error-ERR_NICKNAMEINUSE" title="ERR_NICKNAMEINUSE (433)">
                    <t>Syntax: "433 &lt;nickname&gt; :Nickname is already in use"</t>

                    <t>Returned when a NICK command is sent with a nickname argument which currently exists (i.e. is currently the nickname of another user)</t>
                </section>
                <section anchor="error-ERR_NICKCOLLISION" title="ERR_NICKCOLLISION (436)">
                    <t>Syntax: "433 &lt;nickname&gt; :Nickname collision"</t>

                    <t>Returned when the server detects a nickname collision (e.g. when a heal of a netsplit occurs and both sides have a different user with the same nickname).
                    This error may be followed by a possible termination of the connection through a KILL command or a forcible changing of nick through a NICK command or
                    the use of some other server specific system.</t>
                </section>
                <section anchor="error-ERR_NEEDMOREPARAMS" title="ERR_NEEDMOREPARAMS (461)">
                    <t>Syntax: "433 &lt;command&gt; :Not enough parameters"</t>

                    <t>Returned when a command was sent by the client with not enough parameters.</t>
                </section>
                <section anchor="error-ERR_ALREADYREGISTRED" title="ERR_NEEDMOREPARAMS (462)">
                    <t>Syntax: "462 &lt;command&gt; :You may not reregister"</t>

                    <t>Returned when the client tries to send a command which may be only used at registration time (e.g. PASS, USER) after registration has completed.</t>
                </section>
            </section>
        </section>
    </middle>
    <back>
        <references title="Normative References">
            &RFC2119;
            &RFC3629;
            &RFC1459;
            &RFC2812;
            &RFC3454;
        </references>
    </back>
</rfc>
